
如何来评价一个排序算法的好坏？

有下面三个方面:

1. 时间复杂度，最好情况，最坏情况，平均时间复杂度? 
	1. 怎么优化时间开销？ 一种方式是使用更高效的算法，另一种方式是缩短内部循环的次数. 
2. 空间复杂度，是否会消耗额外的内存空间, 是否是原地排序？
3. 稳定性，我们可能会对同一组元素按照不同的关键字进行多次排序，如果待排序的序列中存在值相同的元素，那么经过排序后，相等元素之间原来的顺序是否变化？



## 冒泡,插入,选择O(n^2)

这两种算法的原理是差不多的:


1. 将待排序数组分为已排序和未排序两部分
2. 每次排序，将未排序部分的某个元素移动到已排序部分指定的位置
3. 重复N次

所以，它们都是两层循环，外层循环控制轮数，内层循环把元素移动到指定的位置。

对于冒泡来说，它的内层循环做的事情，就是比较相邻元素的值，然后把较大的值放到右边，这样一轮下来，最大的值就在右边。重复N次，那么整个数组就有序了.

```
void bubble(ItemType a[], int l, int r){
    int i, j, changed;
    for (i = l ; i < r; i++) {
        for (j = r, changed = 0; j > i; j--) {
            if (less(a[j], a[j-1])) {
                exch(a[j], a[j-1]);
                changed = 1;
            }
        }
        if (!changed) break;
    }
}
```

### 性能分析:

 1. 最好：o(n)，比如 待排序数组 1,2,3,4,5，循环一次
 2. 最坏 o(n^2),比如 待排序数组 5，4，3，2，1
 3. 平均 o(n^2)
 4. 属于原地排序,O(1)
 5. 属于稳定排序

 

-----------------------

插入排序，它的内层循环做的事情，就是把未排序部分的元素依次插入到有序部分的指定位置去。这样外层循环每一轮下来，未排序部分的长度减一，直到未排序部分全部排序完，整个数组就有序了。


```
void sort(ItemType a[], int l, int r){
    int i, j;
    for (i = l + 1; i <= r; i++) {
        for (j = i; j>l; j--) {
            compexch(a[j-1], a[j]);
        }
    }
}
/*
 插入排序
 sort实现中有几个可以优化的点：
 1. 当我们碰到的键不大于正在被插入的键时，应该停止compexch操作.
 2. j > l 测试通常是多余的，我们通过提前把数组的最小值放在第0个位置，可以避免测试语句的调用.
 3. compexch实现里面，交换指令需要三条指令，我们可以采用数据移动方案来减少指令的数量
 */
void insertion(ItemType a[], int l, int r){
    int i, j, min, v;
    for (i = l+1, min = i; i <= r ; i++) {
        if (less(a[i], a[min])) min = i;
    }
    exch(a[min], a[l]);
    for (i = l + 2; i <= r; i++) {
        v = a[i];
        j = i;
        while (less(a[j], a[j-1])) {
            a[j] = a[j-1]; //向后移动
            j--;
        }
        a[j] = v;
    }
}

 插入1：sort
 排序随机元素time: 0.000069 s
 排序已排序的数据源time: 0.000056 s
 排序逆序的数据源time: 0.000109 s
 
 插入优化后: insertion
 排序随机元素time: 0.000005 s
 排序已排序的数据源time: 0.000004 s
 排序逆序的数据源time: 0.000004 s
```


### 性能分析:

1. 最好: O(n),比如 待排序数组 1,2,3,4,5，循环一次
2. 最坏:O(n^2),比如 5，4，3，2，1
3. 平均:O(n^2)
4. 属于原地排序，O(1)
5. 属于稳定排序


--------------------

选择排序，它的内层循环做的事情，就是在未排序部分找到最小的元素，然后放在有序部分的末尾，这样N轮下来，未排序部分的长度每次减一，最后整个数组就有序了。

```
void selection(ItemType items[], int l, int r){
    int i, j, minI;
    for (i = l; i < r; i++) {
        for (j = i+1, minI = i; j <= r ; j++) {
            if (less(items[j], items[minI]))
                minI = j;
        }
        exch(items[minI], items[i]);
    }
}
```


### 性能分析

1. 最好,最坏，平均都是O(n^2),因为每次都会在未排序部分迭代找最小项, 排序一个已经排好顺序的数组，逆序的数组或随机的数组所花的时间是一样的.
2. 属于原地排序,O(1)
3. 非稳定，比如5,8,5,2,9。第一轮下来，2和5交换，那么这两个5的顺序就发生变化了.
4. 内部循环目的是为了查找当前未排序数组的最小项，然后在外层循环更新到已排序数组的末尾，所以它的交换次数为N-1，对于一些具有庞大项，小键指的文件，使用选择排序更为合适，因为数据移动的次数会非常少.


这三种算法，选择排序是最戳的，它的交换(N-1)和比较次数(N^2 / 2)是固定的, 跟输入数据无关. 
冒泡和插入相当，但是插入性能会比冒泡更好，因为冒泡里面核心步骤是交换，而插入排序核心步骤是移位和赋值，它的指令会更少些.


插入排序的性能与数据中的「逆序对」有关。要统计文件中的「逆序对」，我们可以对每个元素左边比它大的元素的数目进行累加来计算。在插入排序中，这个累加的数目就是元素要在插入时要向前移动的步数，如果「逆序对」为0，那么插入排序无需数据移动，整个执行时间是线性的. 对于另外一种部分有序的数组，可能是对已排好序的数组添加一些新元素等使用插入排序就会非常高效，而选用冒泡和选择排序效率就不高.

--------------------




## 归并和快排

前面的O(n^2)的算法适合小规模的数据排序，当涉及到大规模数据的排序问题，归并和快爬就用的上了.

归并和快排都用到了分治思想，非常巧妙。

归并排序的思想：如果要排序一个数组，我们先将数组从中间分为两部分，然后分别对两部分排序，最后再将排序好的两部分合并在一起。


### [归并](./sort/mergeSort.h)

### 性能分析

1.  merge函数的实现里面，我们可以看出首先会N次循环构建一个temp临时排好序的数组，然后依次拷贝。所以归并排序的执行效率和要排序数组的有序程度是无关的，所以时间复杂度是非常稳定的，不管是最好，最坏，平均都是o(n*log(n))
2. 非本地排序
3. 稳定排序，不改变相等元素之前的顺序


-------------------

快排的思想也是利用分治，在待排数组中找到一个数，它前面的数都比它小，它后面的数都比它大。在继续左边部分和右边部分。

### [快排](./sort/quickSort.h)


### 性能分析

1. 大部分情况下都能做到O(n*log(n))
2. 最坏情况下，O(n^2)，比如数组本身就是有序的，它将会进行N次分区
3. 原地排序,O(1)
4. 非稳定排序



### [如何在o(n)内查找一个无序数组中的第K大元素](./sort/kthSmallest.h)

-----------------------


## 使用场景苛刻的线性排序(桶排序，计数排序，基数排序)O(n)

这三种排序的是O(n)级别的排序算法，不过它们对排序数据的要求极其严格，之所以能做到线性的时间复杂度，主要原因是，这三种算法是非基于比较的算法，都不涉及元素间的比较。


这三种算法对排序数据要求很严苛，重点自傲与理解这些排序算法适用的场景.


### 桶排序

桶排序的核心思想是：将要排序的数据分到几个有序的桶里，每个桶再单独排序，最后根据桶的顺序依次取出，组成的序列就有序的。这里对数据的要求有几方面:

1. 待排序数据要很容易就能分进M个桶里
2. 并且这桶和桶之间天然的就是有序的
3. 每个桶里面的元素要劲量平均，不然算法就会退化大O。


### [桶排序代码](./sort/bucketSort.h)


### 计数排序

计数排序是一种特殊情况下的桶排序，在这里每个桶的划分力度为1个单位，所以每个桶内部是不需要重新排序的。很容易理解.

计数排序适合用在数据范围不大的场景中，如果数据范围比要排序的数据n大很多的话，那么就不适合计数排序了。

### [计数排序代码](./sort/countingSort.h)




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

## 索引排序

使用索引排序或指针排序的主要原因是避免侵扰被排序的数据，甚至当被排序的数组是只读时，我们任然能够进行排序。 并且如果我们想要对待排序数组进行多个维度的排序也是非常方便的，通过不修改原始数据，而是建立多个索引数组来进行排序。

使用索引排序或指针排序的第二个原因在于可以避免移动整个记录的开销. 

当需要将原数组按照已排好序的索引数组进行排序时，一种常规的方法是:

```
for (i=0; i< N; i++)
	datasorted[i] = data[a[i]];
```

但这需要额外足够的内存来存储数组的另一个拷贝，同时我们也不能盲目的设置`data[i] = data[a[i]]`来实现原地排序，因为这会覆盖掉data[i]的旧值，导致旧值丢失.


就位排序算法就是用来解决这个问题来的

```
void insitu(ItemType data[], int a[], int n){
    int i,j,k;
    for (i=0; i<n; i++) {
        ItemType v = data[i];
        j = i;
        while (a[j] != i) {
            data[j] = data[a[j]];
            k = a[j]; //k保存下一个即将遍历的位置下标
            a[j] = j; //标记当前数据已经搬移到正确位置
            j = k;
        }
        data[j] = v;
        a[j] = k;
    }
}


ItemType data[] = {'A', 'S', 'O', 'R', 'T', 'I', 'N', 'G', 'E', 'X','A','M','P', 'L', 'E'};
//索引数组的意义在于数组的最小元素下标为0, 数组的次小元素下标为10.....
int idxs[] = {0, 10,8,14,7,5,13,11,6,2,12,3,1,4,9};
insitu(data, idxs, 15);
print(data, 15);
    
    
```
如果a[j] == i，那么表示任何元素已经就位了，否则，将data[j]的值保存到v里面，然后通过循环a[j],a[a[j]]....依次处理，直到再次到达索引i为止. 



| &emsp;题号&emsp; | 题目链接&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| 答案链接&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| &emsp;难度&emsp;  | &emsp;完成度&emsp;  |
| :--: | :--: | :----------------------------------------------------------- | :----------------------------------------------------------- | :------: | :------: |
|  56  | [合并区间](https://leetcode-cn.com/problems/merge-intervals/) | [merge_intervals](./sort/leetcode/merge_intervals.h) | <font color=orange> medium </font> | ✅ |
|  75  | [颜色分类](https://leetcode-cn.com/problems/sort-colors/) | [sort_colors](./sort/leetcode/sort_colors.h) | <font color=orange> medium </font> | ✅ |